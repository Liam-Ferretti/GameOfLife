<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Arial', sans-serif;
      height: 100%;
      overflow: hidden;
      background: #1a1a2e;
      color: #e6e6e6;
    }

    #start-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      padding: 20px;
      box-sizing: border-box;
      text-align: center;
    }

    h1 {
      color: #4cc9f0;
      font-size: 2.5rem;
      margin-bottom: 30px;
      text-shadow: 0 0 10px rgba(76, 201, 240, 0.5);
    }

    .settings, .patterns {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      margin: 15px 0;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    h2 {
      color: #f72585;
      margin-top: 0;
      font-size: 1.5rem;
    }

    .input-group {
      margin: 15px 0;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    label {
      margin-bottom: 8px;
      font-size: 1.1rem;
      color: #e6e6e6;
    }

    input[type="range"] {
      width: 100%;
      height: 10px;
      background: #4a4a6e;
      border-radius: 5px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 25px;
      height: 25px;
      border-radius: 50%;
      background: #f72585;
      cursor: pointer;
    }

    .pattern-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
    }

    .pattern-btn {
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 20px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      min-width: 120px;
    }

    .pattern-btn:hover {
      background: #4895ef;
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .pattern-btn.active {
      background: #f72585;
      transform: translateY(-3px);
      box-shadow: 0 5px 15px rgba(247, 37, 133, 0.4);
    }

    #start-btn {
      background: linear-gradient(135deg, #f72585, #4361ee);
      color: white;
      border: none;
      border-radius: 50px;
      padding: 15px 40px;
      font-size: 1.2rem;
      margin-top: 30px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 20px rgba(247, 37, 133, 0.4);
    }

    #start-btn:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 25px rgba(247, 37, 133, 0.6);
    }

    #simulation-screen {
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    #controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      padding: 15px;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10;
    }

    #controls button {
      background: #4361ee;
      color: white;
      border: none;
      border-radius: 50px;
      padding: 12px 25px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    #controls button:hover {
      background: #4895ef;
      transform: translateY(-3px);
    }

    #pause-btn {
      background: #f72585 !important;
    }

    #canvas-container {
      flex: 1;
      overflow: hidden;
    }

    canvas {
      display: block;
      touch-action: none;
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }
      
      .pattern-buttons {
        flex-direction: column;
      }
      
      .pattern-btn {
        width: 100%;
      }
      
      #controls {
        flex-wrap: wrap;
      }
      
      #controls button {
        flex: 1;
        min-width: 120px;
        padding: 10px 15px;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div id="start-screen">
    <h1>GAME OF LIFE</h1>
    <div class="settings">
      <h2>Impostazioni Griglia</h2>
      <div class="input-group">
        <label for="cell-size">Dimensione Cella:</label>
        <input type="range" id="cell-size" min="5" max="30" value="10">
        <span id="cell-size-value">10</span>
      </div>
      <div class="input-group">
        <label for="density">Densit√† Celle Vive (%):</label>
        <input type="range" id="density" min="1" max="50" value="30">
        <span id="density-value">30</span>
      </div>
    </div>
    
    <div class="patterns">
      <h2>Scegli Pattern</h2>
      <div class="pattern-buttons">
        <button class="pattern-btn" data-pattern="random">Casuale</button>
        <button class="pattern-btn" data-pattern="glider">Aliante</button>
        <button class="pattern-btn" data-pattern="spaceship">Astronave</button>
        <button class="pattern-btn" data-pattern="pulsar">Pulsar</button>
        <button class="pattern-btn" data-pattern="glider-gun">Cannone</button>
      </div>
    </div>
    
    <button id="start-btn">AVVIA SIMULAZIONE</button>
  </div>
  
  <div id="simulation-screen" style="display:none;">
    <div id="controls">
      <button id="pause-btn">PAUSA</button>
      <button id="reset-btn">RESET</button>
      <button id="back-btn">INDIETRO</button>
    </div>
    <main>
      <div id="canvas-container"></div>
    </main>
  </div>
  
  <script>
    // ========== sketch.js ==========
    let size = 10;
    let cols, rows, grid;
    let paused = false;
    let currentPattern = 'random';
    let density = 30;

    function setup() {
      setupEventListeners();
    }

    function draw() {
      if (!grid) return;

      background(0);

      // Draw the grid
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          grid[i][j].show(i, j);
        }
      }

      if (paused) return;

      // Compute next generation
      let nextGrid = make2DArray(cols, rows);
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          grid[i][j].update(i, j, grid, nextGrid);
        }
      }

      grid = nextGrid;
    }

    function startSimulation(pattern) {
      // Get settings from UI
      size = parseInt(document.getElementById('cell-size').value);
      density = parseInt(document.getElementById('density').value);
      currentPattern = pattern;

      // Hide start screen, show simulation
      document.getElementById('start-screen').style.display = 'none';
      document.getElementById('simulation-screen').style.display = 'block';

      // Create canvas
      const container = document.getElementById('canvas-container');
      const canvas = createCanvas(container.clientWidth, container.clientHeight);
      canvas.parent('canvas-container');

      // Calculate grid dimensions based on ACTUAL canvas size
      cols = Math.floor(width / size);
      rows = Math.floor(height / size);

      // Create grid
      grid = make2DArray(cols, rows);

      // Initialize based on pattern
      if (currentPattern === 'random') {
        initializeRandomGrid();
      } else {
        placePattern(currentPattern);
      }

      frameRate(10);
    }

    function initializeRandomGrid() {
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          grid[i][j].state = Math.random() * 100 < density ? 1 : 0;
        }
      }
    }

    function placePattern(patternName) {
      // Clear grid
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          grid[i][j].state = 0;
        }
      }

      const pattern = Patterns.getPattern(patternName);
      if (!pattern) return;

      const patternWidth = pattern[0].length;
      const patternHeight = pattern.length;

      // Calculate center position
      const startX = Math.floor((cols - patternWidth) / 2);
      const startY = Math.floor((rows - patternHeight) / 2);

      // Place pattern
      for (let y = 0; y < patternHeight; y++) {
        for (let x = 0; x < patternWidth; x++) {
          const posX = startX + x;
          const posY = startY + y;

          if (posX >= 0 && posX < cols && posY >= 0 && posY < rows) {
            grid[posX][posY].state = pattern[y][x];
          }
        }
      }
    }

    function setupEventListeners() {
      // Pattern buttons
      document.querySelectorAll('.pattern-btn').forEach(btn => {
        btn.addEventListener('click', handlePattern);
        btn.addEventListener('touchend', handlePattern);
      });

      // Start button
      const startBtn = document.getElementById('start-btn');
      startBtn.addEventListener('click', handleStart);
      startBtn.addEventListener('touchend', handleStart);

      // Control buttons
      document.getElementById('pause-btn').addEventListener('click', handlePause);
      document.getElementById('pause-btn').addEventListener('touchend', handlePause);
      
      document.getElementById('reset-btn').addEventListener('click', handleReset);
      document.getElementById('reset-btn').addEventListener('touchend', handleReset);
      
      document.getElementById('back-btn').addEventListener('click', handleBack);
      document.getElementById('back-btn').addEventListener('touchend', handleBack);

      // Sliders
      document.getElementById('cell-size').addEventListener('input', (e) => {
        document.getElementById('cell-size-value').textContent = e.target.value;
      });

      document.getElementById('density').addEventListener('input', (e) => {
        document.getElementById('density-value').textContent = e.target.value;
      });

      // Window resize
      window.addEventListener('resize', handleResize);
      
      // Prevent touch scroll on buttons
      document.querySelectorAll('button').forEach(btn => {
        btn.addEventListener('touchstart', e => e.preventDefault());
      });
      
      // Event handlers
      function handlePattern(e) {
        e.preventDefault();
        document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      }
      
      function handleStart(e) {
        e.preventDefault();
        const selectedPattern = document.querySelector('.pattern-btn.active')?.dataset.pattern || 'random';
        startSimulation(selectedPattern);
      }
      
      function handlePause(e) {
        e.preventDefault();
        paused = !paused;
        document.getElementById('pause-btn').textContent = paused ? 'RIPRENDI' : 'PAUSA';
      }
      
      function handleReset(e) {
        e.preventDefault();
        if (currentPattern === 'random') {
          initializeRandomGrid();
        } else {
          placePattern(currentPattern);
        }
      }
      
      function handleBack(e) {
        e.preventDefault();
        document.getElementById('simulation-screen').style.display = 'none';
        document.getElementById('start-screen').style.display = 'block';
        const canvas = document.querySelector('canvas');
        if (canvas) canvas.remove();
        grid = null;
      }
      
      function handleResize() {
        if (grid) {
          const container = document.getElementById('canvas-container');
          resizeCanvas(container.clientWidth, container.clientHeight);
          
          // Calculate new grid dimensions
          const newCols = Math.floor(width / size);
          const newRows = Math.floor(height / size);
          
          // Create new grid
          const newGrid = make2DArray(newCols, newRows);
          
          // Copy existing grid state
          for (let i = 0; i < Math.min(cols, newCols); i++) {
            for (let j = 0; j < Math.min(rows, newRows); j++) {
              newGrid[i][j].state = grid[i][j].state;
            }
          }
          
          // Update references
          cols = newCols;
          rows = newRows;
          grid = newGrid;
          
          redraw();
        }
      }
    }

    function make2DArray(col, row) {
      let arr = new Array(col);
      for (let i = 0; i < arr.length; i++) {
        arr[i] = new Array(row);
        for (let j = 0; j < arr[i].length; j++) {
          arr[i][j] = new Cell(0);
        }
      }
      return arr;
    }

    // ========== cell.js ==========
    class Cell {
      constructor(state) {
        this.state = state; // 1 for alive, 0 for dead
      }

      show(i, j) {
        if (this.state === 1) {
          fill(255); // WHITE
        } else {
          fill(0);
        }
        square(i * size, j * size, size);
      }

      countNeighbors(grid, x, y) {
        let sum = 0;
        const cols = grid.length;
        const rows = grid[0].length;

        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            if (i === 0 && j === 0) continue;
            
            const col = (x + i + cols) % cols;
            const row = (y + j + rows) % rows;
            sum += grid[col][row].state;
          }
        }
        return sum;
      }

      update(i, j, grid, nextGrid) {
        const neighbors = this.countNeighbors(grid, i, j);
        
        if (this.state === 1) {
          nextGrid[i][j].state = (neighbors === 2 || neighbors === 3) ? 1 : 0;
        } else {
          nextGrid[i][j].state = (neighbors === 3) ? 1 : 0;
        }
      }
    }

    // ========== patterns.js ==========
    const Patterns = {
      GLIDER: [
        [0, 1, 0],
        [0, 0, 1],
        [1, 1, 1]
      ],
      
      SPACESHIP: [
        [0, 1, 1, 1, 1],
        [1, 0, 0, 0, 1],
        [0, 0, 0, 0, 1],
        [1, 0, 0, 1, 0]
      ],
      
      PULSAR: [
        [0,0,1,1,1,0,0,0,1,1,1,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [1,0,0,0,0,1,0,1,0,0,0,0,1],
        [1,0,0,0,0,1,0,1,0,0,0,0,1],
        [1,0,0,0,0,1,0,1,0,0,0,0,1],
        [0,0,1,1,1,0,0,0,1,1,1,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,1,1,1,0,0,0,1,1,1,0,0],
        [1,0,0,0,0,1,0,1,0,0,0,0,1],
        [1,0,0,0,0,1,0,1,0,0,0,0,1],
        [1,0,0,0,0,1,0,1,0,0,0,0,1],
        [0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,1,1,1,0,0,0,1,1,1,0,0]
      ],
      
      GLIDER_GUN: [
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
        [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
      ],

      getPattern(name) {
        switch(name) {
          case 'glider': return this.GLIDER;
          case 'spaceship': return this.SPACESHIP;
          case 'pulsar': return this.PULSAR;
          case 'glider-gun': return this.GLIDER_GUN;
          default: return null;
        }
      }
    };
  </script>
</body>
</html>